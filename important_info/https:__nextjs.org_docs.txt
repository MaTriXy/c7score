Google search results: Here is a list of crucial technical information from the Next.js documentation to help you when coding:

1.  ### File-System Based Routing

    Next.js uses a file-system-based router, where folders are used to define routes. A special `page.js` file is used to make the route segment publicly accessible and to display UI for that route. For example, a file at `app/dashboard/settings/page.js` would create a `/dashboard/settings` route in your application.

2.  ### Linking and Navigating

    To navigate between pages, you use the `<Link>` component from `next/link`. This component enables client-side navigation, which is faster than a full-page reload, as it only re-renders the segments of the page that have changed. The `<Link>` component can be used with a simple `href` prop for static routes, or with a URL object for dynamic routes.

    ```javascript
    import Link from 'next/link';

    export default function Page() {
      return <Link href="/dashboard">Dashboard</Link>;
    }
    ```

3.  ### Server Components

    By default, components in the `app` directory are React Server Components, which are rendered on the server. This allows for benefits like improved performance, direct access to backend resources, and reduced client-side JavaScript. Server Components can fetch data and render on the server, and the result is then sent to the client.

4.  ### Client Components

    To create a Client Component, which is rendered on the client-side, you need to add the `"use client"` directive at the top of the file. Client Components are necessary when you need to use React hooks like `useState` and `useEffect`, or access browser-only APIs.

    ```javascript
    "use client";

    import { useState } from 'react';

    export default function Counter() {
      const [count, setCount] = useState(0);

      return (
        <div>
          <p>You clicked {count} times</p>
          <button onClick={() => setCount(count + 1)}>Click me</button>
        </div>
      );
    }
    ```

5.  ### Data Fetching with `fetch`

    Next.js extends the native `fetch` API to allow for server-side data fetching with caching and revalidation. By default, `fetch` requests are cached to improve performance. You can control the caching behavior by using the `cache` and `next.revalidate` options in the `fetch` call.

    ```javascript
    async function getData() {
      const res = await fetch('https://api.example.com/data', { next: { revalidate: 3600 } });
      // The return value is *not* serialized
      // You can return Date, Map, Set, etc.

      if (!res.ok) {
        // This will activate the closest `error.js` Error Boundary
        throw new Error('Failed to fetch data');
      }

      return res.json();
    }
    ```

6.  ### Route Handlers for API Routes

    You can create API endpoints by adding a `route.js` (or `.ts`) file inside the `app` directory. These are known as Route Handlers and allow you to create custom request handlers for a given route using the Web Request and Response APIs. You can define handlers for different HTTP methods like GET, POST, etc., by exporting functions with the corresponding names.

    ```javascript
    // app/api/hello/route.js
    export async function GET(request) {
      return new Response('Hello, Next.js!');
    }
    ```

7.  ### Image Optimization with `<Image>`

    The `next/image` component is an extension of the HTML `<img>` element that provides automatic image optimization. It includes features like size optimization, visual stability to prevent layout shift, and lazy loading to speed up page loads. You should use it for both local and remote images to improve performance.

    ```javascript
    import Image from 'next/image';
    import profilePic from '../public/me.png';

    export default function Page() {
      return (
        <Image
          src={profilePic}
          alt="Picture of the author"
          // width={500} automatically provided
          // height={500} automatically provided
          // blurDataURL="data:..." automatically provided
          // placeholder="blur" // Optional blur-up placeholder
        />
      );
    }
    ```

8.  ### Font Optimization with `next/font`

    The `next/font` module allows you to automatically optimize and self-host fonts, including Google Fonts. This helps to improve performance and privacy by removing external network requests. To use a font, you import it from `next/font` and apply it to your components or layouts.

    ```javascript
    import { Inter } from 'next/font/google';

    const inter = Inter({ subsets: ['latin'] });

    export default function RootLayout({ children }) {
      return (
        <html lang="en" className={inter.className}>
          <body>{children}</body>
        </html>
      );
    }
    ```

9.  ### Middleware

    Middleware allows you to run code before a request is completed. This is useful for tasks like authentication, redirection, and modifying request or response headers. You can define middleware in a `middleware.ts` (or `.js`) file at the root of your project. You can use a `matcher` to specify which paths the middleware should run on.

    ```typescript
    import { NextResponse } from 'next/server';
    import type { NextRequest } from 'next/server';

    export function middleware(request: NextRequest) {
      if (request.nextUrl.pathname.startsWith('/about')) {
        return NextResponse.rewrite(new URL('/about-2', request.url));
      }
    }
    ```

10. ### Caching and Revalidation

    Next.js has a built-in caching mechanism to improve performance. You can control caching behavior for `fetch` requests and revalidate data at timed intervals (`revalidate`) or on-demand (`revalidateTag` or `revalidatePath`). Time-based revalidation ensures that data is not older than a specified duration, while on-demand revalidation allows you to update the cache when data changes.