Google search results: Here is a numbered list of the most crucial technical information from the `asynch` library's documentation to help you use it when coding:

1.  ### Connecting with a DSN String
    You can establish a connection to a ClickHouse server by providing a DSN (Data Source Name) string. This string contains all the necessary connection information, including the username, password, host, port, and database name, making it a convenient way to configure your connection.

    ```python
    from asynch import Connection

    async def connect_database():
        async with Connection(
            dsn="clickhouse://ch_user:P@55w0rD:@127.0.0.1:9000/chdb",
        ) as conn:
            pass
    ```

2.  ### Connecting with Individual Parameters
    Alternatively, you can connect by passing the connection details as separate arguments to the `Connection` class. If a DSN string is also provided, it will take priority over these individual parameters.

    ```python
    from asynch import Connection

    async def connect_database():
        async with Connection(
            user="ch_user",
            password="P@55w0rD",
            host="127.0.0.1",
            port=9000,
            database="chdb",
        ) as conn:
            pass
    ```

3.  ### Creating a Table
    To execute SQL statements for tasks like creating a database or a table, you need to acquire a `Cursor` instance from an active connection. You can then use the cursor's `execute` method to run your SQL commands.

    ```python
    from asynch import Connection
    from asynch.cursors import DictCursor

    async def create_table(conn: Connection):
        async with conn.cursor(cursor=DictCursor) as cursor:
            await cursor.execute("CREATE DATABASE IF NOT EXISTS test")
            await cursor.execute("""
                CREATE TABLE if not exists test.asynch (
                    `id` Int32,
                    `string` String
                ) ENGINE = MergeTree ORDER BY id
            """)
    ```

4.  ### Fetching a Single Row
    After executing a `SELECT` query, you can retrieve a single row from the result set using the `fetchone()` method on the cursor. By default, the row is returned as a tuple.

    ```python
    async def fetchone(conn: Connection):
        async with conn.cursor() as cursor:
            await cursor.execute("SELECT 1")
            ret = await cursor.fetchone()
            assert ret == (1,)
    ```

5.  ### Fetching All Rows
    To retrieve all rows from a query result at once, use the `fetchall()` method. This method returns a list of tuples, where each tuple represents a row.

    ```python
    async def fetchall(conn: Connection):
        async with conn.cursor() as cursor:
            await cursor.execute("SELECT 1")
            ret = await cursor.fetchall()
            assert ret == [(1,)]
    ```

6.  ### Using `DictCursor` for Dictionary Results
    If you prefer to work with dictionaries instead of tuples, you can use the `DictCursor`. When creating the cursor, specify `cursor=DictCursor`, and the fetch methods will return rows as a list of dictionaries, with column names as keys.

    ```python
    from asynch.cursors import DictCursor

    async def dict_cursor(conn: Connection):
        async with conn.cursor(cursor=DictCursor) as cursor:
            await cursor.execute("SELECT 1")
            ret = await cursor.fetchall()
            assert ret == [{"1": 1}]
    ```

7.  ### Inserting Data with Dictionaries
    When using a `DictCursor`, you can insert data by passing a list of dictionaries to the `execute` method. Each dictionary should map column names to their corresponding values.

    ```python
    from asynch.cursors import DictCursor

    async def insert_dict(conn: Connection):
        async with conn.cursor(cursor=DictCursor) as cursor:
            ret = await cursor.execute(
                "INSERT INTO test.asynch(id, string) VALUES",
                [{"id": 1, "string": "hello"}]
            )
            assert ret == 1
    ```

8.  ### Inserting Data with Tuples
    You can also insert data using a list of tuples, which is the standard method for the default `Cursor`. Each tuple in the list represents a row of data to be inserted.

    ```python
    async def insert_tuple(conn: Connection):
        async with conn.cursor() as cursor:
            ret = await cursor.execute(
                "INSERT INTO test.asynch(id, string) VALUES",
                [(2, "world")]
            )
            assert ret == 1
    ```

9.  ### Using a Connection Pool
    For applications that require managing multiple connections, `asynch` provides a connection pool. The recommended way to use the pool is with an `async with` statement, which handles the acquisition and release of connections automatically.

    ```python
    from asynch import Pool

    async def use_pool():
        async with Pool(minsize=1, maxsize=2) as pool:
            async with pool.connection() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute("SELECT 1")
                    ret = await cursor.fetchone()
                    assert ret == (1,)
    ```

10. ### Manual Connection Pool Management
    If you need more control over the pool's lifecycle, you can manage it manually. You can initialize the pool and then explicitly call `await pool.startup()` to create the initial connections and `await pool.shutdown()` to close them.

    ```python
    from asynch import Pool

    async def use_pool_manual():
        pool = Pool(minsize=1, maxsize=2)
        await pool.startup()
        # Your application logic here
        await pool.shutdown()
    ```